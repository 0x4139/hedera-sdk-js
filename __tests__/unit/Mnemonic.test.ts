import { Mnemonic } from "../../src/crypto/Mnemonic";
import { MnemonicValidationStatus } from "../../src/crypto/MnemonicValidationStatus";

describe("Mnemonic", () => {
    // Keys.test.ts covers mnemonic -> Ed25519PrivateKey

    it(".generate() generates valid mnemonics", () => {
        const mnemonic = Mnemonic.generate();
        const result = mnemonic.validate();

        expect(result.status).toStrictEqual(MnemonicValidationStatus.Ok);
        expect(result.unknownIndices).toBeUndefined();
        expect(result.isOk()).toBeTruthy();
    });

    it("should produce the expected legacy private key", async() => {
        // root key generated by the iOS wallet, not used anywhere
        const legacyMnemonic = Mnemonic.fromString(
            "jolly kidnap Tom lawn drunk chick optic lust mutter mole bride galley dense member sage neural widow decide curb aboard margin manure"
        );
        const expectedLegacyKey =
            "302e020100300506032b657004220420f08539822cf6ac9be1c7912f2b0afcd44afd766a77d6b05437cefa697496ab5f";
        const key = (await (await legacyMnemonic.toLegacyPrivateKey()).legacyDerive(1)).toString();
        expect(key.toString()).toStrictEqual(
            expectedLegacyKey
        );
    });

    const strings = [
        "inmate flip alley wear offer often piece magnet surge toddler submit right radio absent pear floor belt raven price stove replace reduce plate home",
        "tiny denial casual grass skull spare awkward indoor ethics dash enough flavor good daughter early hard rug staff capable swallow raise flavor empty angle",
        "ramp april job flavor surround pyramid fish sea good know blame gate village viable include mixed term draft among monitor swear swing novel track"
    ];

    it.each(strings)("Mnemonic.fromString(%s).validate() returns success", (string) => {
        const mnemonic = Mnemonic.fromString(string);
        const result = mnemonic.validate();

        expect(result.status).toStrictEqual(MnemonicValidationStatus.Ok);
        expect(result.unknownIndices).toBeUndefined();
        expect(result.isOk()).toBeTruthy();
    });

    it(".validate() returns error on short word list", () => {
        const mnemonic = new Mnemonic([ "lorem", "ipsum", "dolor" ]);
        const result = mnemonic.validate();

        expect(result.status).toStrictEqual(MnemonicValidationStatus.BadLength);
        expect(result.unknownIndices).toBeUndefined();
        expect(result.isOk()).toBeFalsy();
    });

    it(".validate() returns error on invalid words", () => {
        const words = [
            "abandon",
            "ability",
            "able",
            "about",
            "above",
            "absent",
            "adsorb", // typo from "absorb"
            "abstract",
            "absurd",
            "abuse",
            "access",
            "accident",
            "acount", // typo from "account"
            "accuse",
            "achieve",
            "acid",
            "acoustic",
            "acquired", // typo from "acquire"
            "across",
            "act",
            "action",
            "actor",
            "actress",
            "actual"
        ];

        const mnemonic = new Mnemonic(words);
        const result = mnemonic.validate();

        expect(result.status).toStrictEqual(MnemonicValidationStatus.UnknownWords);
        expect(result.unknownIndices).toStrictEqual([ 6, 12, 17 ]);
        expect(result.isOk()).toBeFalsy();
    });

    it(".validate() returns bad checksum result", () => {
        // this mnemonic was just made up, the checksum should definitely not match
        const words = [
            "abandon",
            "ability",
            "able",
            "about",
            "above",
            "absent",
            "absorb",
            "abstract",
            "absurd",
            "abuse",
            "access",
            "accident",
            "account",
            "accuse",
            "achieve",
            "acid",
            "acoustic",
            "acquire",
            "across",
            "act",
            "action",
            "actor",
            "actress",
            "actual"
        ];

        const mnemonic = new Mnemonic(words);
        const result = mnemonic.validate();

        expect(result.status).toStrictEqual(MnemonicValidationStatus.ChecksumMismatch);
        expect(result.unknownIndices).toBeUndefined();
        expect(result.isOk()).toBeFalsy();
    });

    it("legacy2 mnemonic should work", async () => {
        const words = [
            "obvious",
            "favorite",
            "remain",
            "caution",
            "remove",
            "laptop",
            "base",
            "vacant",
            "increase",
            "video",
            "erase",
            "pass",
            "sniff",
            "sausage",
            "knock",
            "grid",
            "argue",
            "salt",
            "romance",
            "way",
            "alone",
            "fever",
            "slush",
            "dune",
        ];

        const legacy = new Mnemonic(words);
        const legacyPrivateKey = await legacy.toLegacyPrivateKey();

        expect(legacyPrivateKey.toString()).toStrictEqual("302e020100300506032b6570042204202b7345f302a10c2a6d55bf8b7af40f125ec41d780957826006d30776f0c441fb");
    });
});
