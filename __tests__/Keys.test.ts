import {
    generateMnemonic, Ed25519PrivateKey, Ed25519PublicKey,
} from '../src/Keys';

// key from hedera-sdk-java tests, not used anywhere
const privKeyBytes = Uint8Array.of(
    -37, 72, 75, -126, -114, 100, -78, -40, -15, 44, -29, -64, -96, -23, 58, 11, -116, -50,
    122, -15, -69, -113, 57, -55, 119, 50, 57, 68, -126, 83, -114, 16);

const privKeyStr = '302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10';

const pubKeyBytes = Uint8Array.of(
    -32, -56, -20, 39, 88, -91, -121, -97, -6, -62, 38, -95, 60, 12, 81, 107, 121, -98, 114,
    -29, 81, 65, -96, -35, -126, -113, -108, -45, 121, -120, -92, -73);

const pubKeyStr = '302a300506032b6570032100e0c8ec2758a5879ffac226a13c0c516b799e72e35141a0dd828f94d37988a4b7';

// generated by hedera-keygen-java, not used anywhere
const mnemonic = 'inmate flip alley wear offer often piece magnet surge toddler submit right radio absent pear floor belt raven price stove replace reduce plate home';
const mnemonicKey = '302e020100300506032b6570042204203988e39bb91007f3bedcb47b0d9384463ba7d922d74d1306f7a4c8a2881fac9e';

const passphrase = 'asdf1234';

describe('Ed25519PrivateKey', () => {
    it('toString() produces correctly encoded string', () => {
        const privateKey = Ed25519PrivateKey.fromBytes(privKeyBytes);
        expect(privateKey.toString()).toStrictEqual(privKeyStr);
    });

    it('publicKey is the same', () => {
        const privateKey = Ed25519PrivateKey.fromBytes(privKeyBytes);
        expect(privateKey.publicKey.toBytes()).toStrictEqual(pubKeyBytes);
    });

    it('fromString returns correct value', () => {
        const privateKey = Ed25519PrivateKey.fromString(privKeyStr);
        expect(privateKey.toBytes()).toStrictEqual(privKeyBytes);
    });

    it('fromMnemonic() produces correct value', async () => {
        const decodedKey = Ed25519PrivateKey.fromString(mnemonicKey);
        let key;

        // eslint-disable-next-line no-useless-catch
        try {
            key = await Ed25519PrivateKey.fromMnemonic(mnemonic);
        } catch (error) {
            // to get actual stack trace before Promise mangles it
            throw error;
        }

        expect(key.toBytes()).toStrictEqual(decodedKey.toBytes());
    });

    it('createKeystore() creates loadable keystores', async () => {
        const key1 = Ed25519PrivateKey.fromBytes(privKeyBytes);
        const keystoreBytes = await key1.createKeystore(passphrase);
        const key2 = await Ed25519PrivateKey.fromKeystore(keystoreBytes, passphrase);

        expect(key1.toBytes()).toStrictEqual(key2.toBytes());
    });
});

describe('Ed25519PublicKey', function () {
    it('toString() produces correctly encoded string', () => {
        const publicKey = new Ed25519PublicKey(pubKeyBytes);
        expect(publicKey.toString()).toStrictEqual(pubKeyStr);
    });

    it('fromString returns correct value', () => {
        const publicKey = Ed25519PublicKey.fromString(pubKeyStr);
        expect(publicKey.toBytes()).toStrictEqual(pubKeyBytes);
    });
});

test('generateMnemonic produces a recoverable private key', async () => {
    const mnemonic = generateMnemonic();

    const key1 = await mnemonic.generateKey();
    const key2 = await Ed25519PrivateKey.fromMnemonic(mnemonic.mnemonic);
    expect(key1.toBytes()).toStrictEqual(key2.toBytes());
});


